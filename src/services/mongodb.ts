
import { MongoClient, ServerApiVersion, Db, Collection, FindOneAndUpdateOptions, ObjectId } from 'mongodb';

// Define the interface for feedback data in the database
export interface FeedbackDocument {
  _id?: import('mongodb').ObjectId; // Optional because it's generated by MongoDB
  name: string;
  email: string | null; // Allow null for optional email
  message: string;
  submittedAt: Date;
}

// Define the interface for stats data
export interface StatsDocument {
    _id: string; // Use a specific ID like 'predictionStats'
    count: number;
}

// Define the interface for forum message data
export interface ForumMessageDocument {
  _id?: ObjectId;
  forumId: string; // e.g., 'common', 'vellore', 'chennai'
  author: string;
  content: string;
  timestamp: Date;
}

// Define the interface for student rank data
export interface StudentRankDataDocument {
  _id?: ObjectId;
  rank: number;
  college: string;
  course: string;
  category: number; // Fee category 1-5
  submittedAt: Date;
}

// Define the interface for testimonial data
export interface TestimonialDocument {
  _id?: ObjectId;
  name: string;
  message: string;
  // Optional: add other fields like 'course', 'year', 'imageUrl' if needed
}


const mongoUri = process.env.MONGO_URI;
const dbName = 'rank_predictor'; // Define the database name
const feedbackCollectionName = 'feedback'; // Define the feedback collection name
const statsCollectionName = 'stats'; // Define the stats collection name
const forumMessagesCollectionName = 'forum_messages'; // Define the forum messages collection name
const studentRankDataCollectionName = 'student_rank_data'; // Define the student rank data collection name
const testimonialsCollectionName = 'testimonials'; // Define the testimonials collection name


if (!mongoUri) {
  console.error('CRITICAL: MONGO_URI environment variable is not set.');
  // Consider throwing an error in production if the URI is essential at startup
  // throw new Error('MONGO_URI environment variable is not set.');
} else {
  console.log('MONGO_URI environment variable is set.'); // Confirm URI is present
}

let client: MongoClient | null = null;
let db: Db | null = null;
let feedbackCollection: Collection<FeedbackDocument> | null = null;
let statsCollection: Collection<StatsDocument> | null = null;
let forumMessagesCollection: Collection<ForumMessageDocument> | null = null;
let studentRankDataCollection: Collection<StudentRankDataDocument> | null = null;
let testimonialsCollection: Collection<TestimonialDocument> | null = null;


// Cache the promise for the database connection
let connectionPromise: Promise<{
  db: Db;
  feedbackCollection: Collection<FeedbackDocument>;
  statsCollection: Collection<StatsDocument>;
  forumMessagesCollection: Collection<ForumMessageDocument>;
  studentRankDataCollection: Collection<StudentRankDataDocument>;
  testimonialsCollection: Collection<TestimonialDocument>;
}> | null = null;


async function connectToDatabase(): Promise<{
  db: Db;
  feedbackCollection: Collection<FeedbackDocument>;
  statsCollection: Collection<StatsDocument>;
  forumMessagesCollection: Collection<ForumMessageDocument>;
  studentRankDataCollection: Collection<StudentRankDataDocument>;
  testimonialsCollection: Collection<TestimonialDocument>;
}> {
  // If a connection promise exists, reuse it
  if (connectionPromise) {
    console.log('[MongoDB] Reusing existing connection promise.');
    return connectionPromise;
  }

  if (!mongoUri) {
     console.error('[MongoDB] Connection failed: MONGO_URI is not set.');
     throw new Error('MONGO_URI environment variable is not set.');
  }

  console.log('[MongoDB] Creating new connection promise...');
  connectionPromise = (async () => {
    client = new MongoClient(mongoUri, {
      serverApi: {
        version: ServerApiVersion.v1,
        strict: true,
        deprecationErrors: true,
      }
    });

    try {
      console.log('[MongoDB] Attempting to connect...');
      await client.connect();
      console.log('[MongoDB] Connection successful.');
      db = client.db(dbName);
      feedbackCollection = db.collection<FeedbackDocument>(feedbackCollectionName);
      statsCollection = db.collection<StatsDocument>(statsCollectionName);
      forumMessagesCollection = db.collection<ForumMessageDocument>(forumMessagesCollectionName);
      studentRankDataCollection = db.collection<StudentRankDataDocument>(studentRankDataCollectionName);
      testimonialsCollection = db.collection<TestimonialDocument>(testimonialsCollectionName);

      console.log("[MongoDB] Connected to database:", dbName, "collections:", feedbackCollectionName, statsCollectionName, forumMessagesCollectionName, studentRankDataCollectionName, testimonialsCollectionName);


      // Ensure the collection exists (optional, creates if not present)
       try {
          await db.command({ ping: 1 });
          console.log("[MongoDB] Ping successful.");
       } catch (pingError) {
          console.error("[MongoDB] Ping failed:", pingError);
          // Depending on requirements, might want to throw or handle differently
       }


      return { db, feedbackCollection, statsCollection, forumMessagesCollection, studentRankDataCollection, testimonialsCollection };
    } catch (error) {
      console.error('[MongoDB] Connection failed:', error);
      // Reset client and promise on failure to allow retries
      client = null;
      db = null;
      feedbackCollection = null;
      statsCollection = null;
      forumMessagesCollection = null;
      studentRankDataCollection = null;
      testimonialsCollection = null;
      connectionPromise = null; // Allow retrying connection establishment
      throw error; // Re-throw the error
    }
  })();

  return connectionPromise;
}

/**
 * Adds a feedback document to the MongoDB database.
 * Handles connection establishment and error management.
 *
 * @param feedbackData - The feedback data to insert (excluding _id).
 * @returns An object indicating success status and optionally an error message.
 */
export async function addFeedbackToDB(feedbackData: Omit<FeedbackDocument, '_id'>): Promise<{ success: boolean; error?: string }> {
   console.log('[addFeedbackToDB] Function called.');
  try {
    console.log('[addFeedbackToDB] Connecting to database...');
    const { feedbackCollection: collection } = await connectToDatabase();

    if (!collection) {
        console.error("[addFeedbackToDB] Failed to get feedback collection object after connect.");
        throw new Error("Feedback database collection is not available.");
    }
     console.log('[addFeedbackToDB] Got feedback collection object. Inserting document...');

    const result = await collection.insertOne(feedbackData);

    if (result.insertedId) {
      console.log('[addFeedbackToDB] Feedback inserted successfully with ID:', result.insertedId);
      return { success: true };
    } else {
       console.error('[addFeedbackToDB] MongoDB insertion acknowledged, but no insertedId returned.');
      return { success: false, error: 'Database insertion failed (no ID returned).' };
    }
  } catch (error) {
    console.error('[addFeedbackToDB] Error during database operation:', error);
    return { success: false, error: error instanceof Error ? error.message : 'An unknown database error occurred.' };
  }
}


/**
 * Increments the prediction counter in the stats collection.
 * Uses findOneAndUpdate with upsert to ensure the document exists.
 * @returns An object indicating success status and optionally an error message or the updated document.
 */
export async function incrementPredictionCount(): Promise<{ success: boolean; error?: string; updatedCount?: number }> {
    console.log('[incrementPredictionCount] Function called.');
    try {
        console.log('[incrementPredictionCount] Connecting to database...');
        const { statsCollection: collection } = await connectToDatabase();

        if (!collection) {
            console.error("[incrementPredictionCount] Failed to get stats collection object after connect.");
            throw new Error("Stats database collection is not available.");
        }
        console.log('[incrementPredictionCount] Got stats collection object. Incrementing count...');

        const filter = { _id: 'predictionStats' };
        const update = { $inc: { count: 1 } };
        const options: FindOneAndUpdateOptions = { upsert: true, returnDocument: 'after' };

        const result = await collection.findOneAndUpdate(filter, update, options);
        const updatedCount = result?.count;

        if (updatedCount !== undefined) {
            console.log('[incrementPredictionCount] Count incremented successfully. New count:', updatedCount);
            return { success: true, updatedCount };
        } else {
             console.error('[incrementPredictionCount] findOneAndUpdate did not return the expected document structure or count.');
             return { success: false, error: 'Failed to retrieve updated prediction count after incrementing.' };
        }
    } catch (error) {
        console.error('[incrementPredictionCount] Error during database operation:', error);
        return { success: false, error: error instanceof Error ? error.message : 'An unknown database error occurred.' };
    }
}


/**
 * Gets the current prediction count from the stats collection.
 * @returns An object indicating success status, the count, and optionally an error message.
 */
export async function getPredictionCount(): Promise<{ success: boolean; count?: number; error?: string }> {
    console.log('[getPredictionCount] Function called.');
    try {
        console.log('[getPredictionCount] Connecting to database...');
        const { statsCollection: collection } = await connectToDatabase();

         if (!collection) {
            console.error("[getPredictionCount] Failed to get stats collection object after connect.");
            throw new Error("Stats database collection is not available.");
        }
        console.log('[getPredictionCount] Got stats collection object. Fetching count...');


        const result = await collection.findOne({ _id: 'predictionStats' });

        if (result) {
            console.log('[getPredictionCount] Count fetched successfully:', result.count);
            return { success: true, count: result.count };
        } else {
            console.log('[getPredictionCount] Stats document not found, returning count 0.');
            return { success: true, count: 0 }; // Return 0 if the document doesn't exist yet
        }
    } catch (error) {
        console.error('[getPredictionCount] Error during database operation:', error);
        return { success: false, error: error instanceof Error ? error.message : 'An unknown database error occurred.' };
    }
}

/**
 * Gets the total number of feedback documents in the feedback collection.
 * @returns An object indicating success status, the count, and optionally an error message.
 */
export async function getFeedbackCount(): Promise<{ success: boolean; count?: number; error?: string }> {
    console.log('[getFeedbackCount DB] Function called.');
    try {
        console.log('[getFeedbackCount DB] Connecting to database...');
        const { feedbackCollection: collection } = await connectToDatabase();

        if (!collection) {
            console.error("[getFeedbackCount DB] Failed to get feedback collection object after connect.");
            throw new Error("Feedback database collection is not available.");
        }
        console.log('[getFeedbackCount DB] Got feedback collection object. Counting documents...');

        const count = await collection.countDocuments();

        console.log('[getFeedbackCount DB] Feedback count fetched successfully:', count);
        return { success: true, count: count };

    } catch (error) {
        console.error('[getFeedbackCount DB] Error during database operation:', error);
        return { success: false, error: error instanceof Error ? error.message : 'An unknown database error occurred.', count: 0 }; // Return 0 on error
    }
}

/**
 * Gets the total number of student rank data documents in the student_rank_data collection.
 * @returns An object indicating success status, the count, and optionally an error message.
 */
export async function getStudentRankDataCount(): Promise<{ success: boolean; count?: number; error?: string }> {
    console.log('[getStudentRankDataCount DB] Function called.');
    try {
        console.log('[getStudentRankDataCount DB] Connecting to database...');
        const { studentRankDataCollection: collection } = await connectToDatabase();

        if (!collection) {
            console.error("[getStudentRankDataCount DB] Failed to get student rank data collection object after connect.");
            throw new Error("Student rank data database collection is not available.");
        }
        console.log('[getStudentRankDataCount DB] Got student rank data collection object. Counting documents...');

        const count = await collection.countDocuments();

        console.log('[getStudentRankDataCount DB] Student rank data count fetched successfully:', count);
        return { success: true, count: count };

    } catch (error) {
        console.error('[getStudentRankDataCount DB] Error during database operation:', error);
        return { success: false, error: error instanceof Error ? error.message : 'An unknown database error occurred.', count: 0 }; // Return 0 on error
    }
}


/**
 * Adds a forum message document to the MongoDB database.
 * @param messageData - The forum message data to insert.
 * @returns An object indicating success status, the inserted message, and optionally an error message.
 */
export async function addMessageToDB(
  messageData: Omit<ForumMessageDocument, '_id'>
): Promise<{ success: boolean; insertedMessage?: ForumMessageDocument; error?: string }> {
  console.log('[addMessageToDB] Function called for forum:', messageData.forumId);
  try {
    const { forumMessagesCollection: collection } = await connectToDatabase();
    if (!collection) {
      throw new Error("Forum messages database collection is not available.");
    }
    const result = await collection.insertOne(messageData as ForumMessageDocument); // Cast to include potential _id by MongoDB
    if (result.insertedId) {
      const insertedMessage = { ...messageData, _id: result.insertedId }; // Construct the full message object
      console.log('[addMessageToDB] Message inserted successfully with ID:', result.insertedId);
      return { success: true, insertedMessage };
    } else {
      return { success: false, error: 'Database insertion failed (no ID returned).' };
    }
  } catch (error) {
    console.error('[addMessageToDB] Error during database operation:', error);
    return { success: false, error: error instanceof Error ? error.message : 'An unknown database error occurred.' };
  }
}

/**
 * Gets messages for a specific forum from the MongoDB database.
 * @param forumId - The ID of the forum to fetch messages for.
 * @returns An object indicating success status, the array of messages, and optionally an error message.
 */
export async function getMessagesFromDB(
  forumId: string
): Promise<{ success: boolean; messages?: ForumMessageDocument[]; error?: string }> {
  console.log('[getMessagesFromDB] Function called for forum:', forumId);
  try {
    const { forumMessagesCollection: collection } = await connectToDatabase();
    if (!collection) {
      throw new Error("Forum messages database collection is not available.");
    }
    // Fetch messages and sort by timestamp in ascending order (oldest first)
    // Add a limit to prevent fetching too many messages at once, e.g., last 100 messages.
    const messages = await collection.find({ forumId }).sort({ timestamp: 1 }).limit(100).toArray();
    console.log('[getMessagesFromDB] Fetched', messages.length, 'messages for forum:', forumId);
    return { success: true, messages };
  } catch (error) {
    console.error('[getMessagesFromDB] Error during database operation:', error);
    return { success: false, error: error instanceof Error ? error.message : 'An unknown database error occurred.' };
  }
}

/**
 * Adds a student rank data document to the MongoDB database.
 * @param rankData - The student rank data to insert.
 * @returns An object indicating success status, the inserted data, and optionally an error message.
 */
export async function addStudentRankDataToDB(
  rankData: Omit<StudentRankDataDocument, '_id'>
): Promise<{ success: boolean; insertedData?: StudentRankDataDocument; error?: string }> {
  console.log('[addStudentRankDataToDB] Function called for rank:', rankData.rank);
  try {
    const { studentRankDataCollection: collection } = await connectToDatabase();
    if (!collection) {
      throw new Error("Student rank data database collection is not available.");
    }
    const result = await collection.insertOne(rankData as StudentRankDataDocument);
    if (result.insertedId) {
      const insertedData = { ...rankData, _id: result.insertedId };
      console.log('[addStudentRankDataToDB] Data inserted successfully with ID:', result.insertedId);
      return { success: true, insertedData };
    } else {
      return { success: false, error: 'Database insertion failed (no ID returned).' };
    }
  } catch (error) {
    console.error('[addStudentRankDataToDB] Error during database operation:', error);
    return { success: false, error: error instanceof Error ? error.message : 'An unknown database error occurred.' };
  }
}

/**
 * Gets testimonials from the MongoDB database.
 * @returns An object indicating success status, the array of testimonials, and optionally an error message.
 */
export async function getTestimonialsFromDB(): Promise<{
  success: boolean;
  testimonials?: TestimonialDocument[];
  error?: string;
}> {
  console.log('[getTestimonialsFromDB] Function called.');
  try {
    const { testimonialsCollection: collection } = await connectToDatabase();
    if (!collection) {
      throw new Error("Testimonials database collection is not available.");
    }
    // Fetch testimonials, sort by _id descending (newest first) or a timestamp if available
    // Limit to a reasonable number, e.g., 10-15
    const testimonials = await collection.find({}).sort({ _id: -1 }).limit(12).toArray();
    console.log('[getTestimonialsFromDB] Fetched', testimonials.length, 'testimonials.');
    return { success: true, testimonials };
  } catch (error) {
    console.error('[getTestimonialsFromDB] Error during database operation:', error);
    return { success: false, error: error instanceof Error ? error.message : 'An unknown database error occurred.' };
  }
}

/**
 * Gets all student rank data from the MongoDB database.
 * Converts ObjectId _id to string for each document.
 * @returns An object indicating success status, the array of student rank data, and optionally an error message.
 */
export async function getAllStudentRankDataFromDB(): Promise<{
  success: boolean;
  data?: StudentRankDataDocument[]; // Use StudentRankDataDocument as it includes ObjectId for DB ops
  error?: string;
}> {
  console.log('[getAllStudentRankDataFromDB] Function called.');
  try {
    const { studentRankDataCollection: collection } = await connectToDatabase();
    if (!collection) {
      throw new Error("Student rank data database collection is not available.");
    }
    const allData = await collection.find({}).sort({ college: 1, course: 1, category: 1, rank: 1 }).toArray();
    console.log('[getAllStudentRankDataFromDB] Fetched', allData.length, 'student rank data entries.');
    return { success: true, data: allData };
  } catch (error) {
    console.error('[getAllStudentRankDataFromDB] Error during database operation:', error);
    return { success: false, error: error instanceof Error ? error.message : 'An unknown database error occurred.' };
  }
}
